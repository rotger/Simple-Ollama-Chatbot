<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ollama Standalone Chat</title>

    <link id="prism-link" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            height: 100vh;
            margin: 0;
            background-color: #f6f8fa;
            color: #24292f;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            height: 95vh;
            width: 100%;
            max-width: 1200px;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            box-shadow: 0 1px 0 rgba(27,31,36,0.04), 0 3px 6px rgba(27,31,36,0.1);
            background-color: #ffffff;
            overflow: hidden;
        }

        .header-section {
            padding: 16px;
            background-color: #f6f8fa;
            border-bottom: 1px solid #d0d7de;
        }

            .header-section label:not(.collapsible-header-label) {
                font-weight: 600;
                margin-bottom: 8px;
                display: block;
                font-size: 14px;
            }

            .header-section select,
            .header-section textarea,
            .header-section input[type="text"] {
                width: 100%;
                padding: 8px 12px;
                font-size: 14px;
                line-height: 20px;
                color: #24292f;
                background-color: #ffffff;
                border: 1px solid #d0d7de;
                border-radius: 6px;
                box-shadow: inset 0 1px 0 rgba(27,31,36,0.075);
                vertical-align: middle;
                box-sizing: border-box;
            }

                .header-section select:focus,
                .header-section textarea:focus,
                .header-section input[type="text"]:focus {
                    border-color: #0969da;
                    outline: none;
                    box-shadow: inset 0 1px 0 rgba(27,31,36,0.075), 0 0 0 3px rgba(9,105,218,0.3);
                }

        .model-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

            .model-selector label {
                margin-bottom: 0;
                flex-shrink: 0;
            }

            .model-selector select,
            .model-selector input[type="text"] {
                flex-grow: 1;
                min-width: 0;
                width: auto;
            }

        .remove-message-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(192, 0, 0, 0.7);
            color: white;
            border: none;
            max-width: 10%;
            padding: 4px 6px;
            cursor: pointer;
            font-size: 12px;
            border-radius: 4px;
        }

            .remove-message-btn:hover {
                    background-color: rgba(160, 0, 0, 0.8);
            }

        #update-ollama-url-button {
            flex-shrink: 0;
            width: 38px;
            height: 38px;
            padding: 0;
            font-size: 1.5em;
            line-height: 38px;
            text-align: center;
            color: #24292f;
            background-color: #f6f8fa;
            border: 1px solid rgba(27,31,36,0.15);
            cursor: pointer;
            border-radius: 6px;
            transition: background-color 0.1s ease-in-out, border-color 0.1s ease-in-out;
        }

            #update-ollama-url-button:hover {
                background-color: #f3f4f6;
                border-color: rgba(27,31,36,0.25);
            }

        #theme-toggle-button {
            flex-shrink: 0;
            width: 38px;
            height: 38px;
            padding: 0;
            font-size: 1.5em;
            line-height: 38px;
            text-align: center;
            color: #24292f;
            background-color: #f6f8fa;
            border: 1px solid rgba(27,31,36,0.15);
            cursor: pointer;
            border-radius: 6px;
            transition: background-color 0.1s ease-in-out, border-color 0.1s ease-in-out;
        }

            #theme-toggle-button:hover {
                background-color: #f3f4f6;
                border-color: rgba(27,31,36,0.25);
            }

        .system-prompt-area textarea {
            min-height: 60px;
            resize: vertical;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 8px 0;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #24292f;
        }

            .collapsible-header:hover {
                color: #0969da;
            }

        .toggle-icon {
            font-family: monospace;
            font-weight: bold;
            margin-left: 5px;
            display: inline-block;
            width: 20px;
            text-align: center;
        }

        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .message-bubble {
            position: relative;
            padding: 12px 16px;
            border-radius: 6px;
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.5;
            border: 1px solid #d0d7de;
        }

            .message-bubble .message-sender {
                font-size: 13px;
                font-weight: 600;
                margin-bottom: 4px;
                color: #57606a;
            }

            .message-bubble .message-timestamp {
                font-size: 12px;
                color: #57606a;
                text-align: right;
                margin-top: 8px;
            }

            .message-bubble .attachment-note {
                font-size: 0.85em;
                color: #57606a;
                margin-bottom: 6px;
                font-style: italic;
            }

            /* Style for the scraped content summary within the user bubble */
            .message-bubble .scraped-info-summary {
                font-size: 0.85em;
                color: #57606a;
                display: block;
                margin-top: 8px;
                border-top: 1px dashed #d0d7de; /* Separator line */
            }

                .message-bubble .scraped-info-summary strong {
                    color: #57606a;
                    font-weight: inherit;
                }

                .message-bubble .scraped-info-summary code { /* Style code within summary */
                    background-color: rgba(175,184,193,0.2);
                    padding: 0.1em 0.3em;
                    font-size: 90%;
                    border-radius: 3px;
                    font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
                }


        .user-message {
            background-color: #EFF6FF;
            border-color: #C6DBEF;
            color: #24292f;
            align-self: flex-end;
        }

        .ai-message {
            background-color: #f6f8fa;
            border-color: #d0d7de;
            color: #24292f;
            align-self: flex-start;
        }

            .ai-message em { /* Style for "Typing..." */
                color: #57606a;
                font-style: italic;
            }

        .collapsible-think-section {
            margin: 10px 0;
            border: 1px dashed #0969da;
            border-radius: 6px;
            background-color: #ffffff;
        }

            .collapsible-think-section .think-header {
                cursor: pointer;
                background-color: #e6f7ff;
                color: #0366d6;
                padding: 6px 10px;
                font-size: 0.9em;
                font-weight: 500;
                border-bottom: 1px dashed #0969da;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

                .collapsible-think-section .think-header:hover {
                    background-color: #ccebff;
                }

            .collapsible-think-section .think-content {
                padding: 10px;
                background-color: #f6f8fa;
                border-top: none;
                font-size: 0.95em;
            }

                .collapsible-think-section .think-content pre {
                    font-size: 80%; /* Reduce size of code blocks inside think */
                }

        #file-management-area {
            padding: 10px;
            border-top: 1px solid #d0d7de;
            border-bottom: 1px solid #d0d7de;
            background-color: #f9f9f9;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

            #file-management-area.drag-over {
                background-color: #e8f0fe;
                border: 2px dashed #0366d6;
            }

            #file-management-area.disabled-drop-zone {
                pointer-events: none;
                opacity: 0.7;
            }

        #drop-zone-instruction {
            margin: 5px 0;
            color: #57606a;
            font-size: 13px;
        }

        #selected-files-container {
            margin-top: 8px;
            text-align: left;
            max-height: 100px;
            overflow-y: auto;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 8px;
            background-color: #ffffff;
            border: 1px solid #d0d7de;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 13px;
            color: #24292f;
        }

            .file-item span {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                margin-right: 8px;
                flex-grow: 1;
            }

        .remove-file-btn {
            background: none;
            border: 1px solid transparent;
            color: #cf222e;
            font-weight: bold;
            cursor: pointer;
            padding: 2px 5px;
            border-radius: 4px;
            line-height: 1;
        }

            .remove-file-btn:hover {
                color: white;
                background-color: #cf222e;
                border-color: #a40e26;
            }


        .chat-input-area {
            display: flex;
            padding: 16px 16px 0px 16px; /* Reduced bottom padding */
            background-color: #ffffff;
            gap: 8px;
            align-items: flex-start;
        }

        .textarea-wrapper { /* New wrapper for textarea and highlighter */
            position: relative;
            flex-grow: 1;
            font-family: inherit; /* Ensure font propagates */
            font-size: 14px;
            line-height: 20px;
        }

        #user-input-highlighter {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 8px 12px; /* Match textarea */
            border: 1px solid transparent; /* Match textarea border for layout */
            border-radius: 6px; /* Match textarea */
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: hidden; /* Match textarea scroll behavior */
            pointer-events: none; /* Click through */
            z-index: 0;
            color: transparent; /* Base text is transparent, spans provide visual */
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
        }

        .highlighted-url {
            background-color: rgba(173, 216, 230, 0.4); /* Light blue background */
            border-radius: 3px;
        }


        .chat-input-area textarea {
            width: 100%; /* Fill wrapper */
            resize: none;
            border-radius: 6px;
            padding: 8px 12px;
            border: 1px solid #d0d7de;
            font-family: inherit;
            font-size: 14px;
            line-height: 20px;
            box-shadow: inset 0 1px 0 rgba(27,31,36,0.075);
            min-height: 38px; /* Start with a smaller height */
            max-height: 250px; /* Limit maximum expansion */
            box-sizing: border-box;
            position: relative;
            z-index: 1;
            background-color: transparent !important; /* Crucial for highlighter visibility */
            overflow-y: auto;
        }

            .chat-input-area textarea:focus {
                border-color: #0969da;
                outline: none;
                box-shadow: inset 0 1px 0 rgba(27,31,36,0.075), 0 0 0 3px rgba(9,105,218,0.3);
            }

        .chat-input-area button {
            border-radius: 6px;
            padding: 8px 16px;
            border: 1px solid rgba(27,31,36,0.15);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background-color 0.1s ease-in-out;
            height: 38px;
            line-height: 20px;
            flex-shrink: 0;
        }

        .button-stack {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-shrink: 0;
        }

            .button-stack button {
                width: 100%;
                box-sizing: border-box;
            }

        #send-button {
            background-color: #2da44e;
            color: white;
        }

            #send-button:hover {
                background-color: #2c974b;
            }

            #send-button:disabled {
                background-color: #94d3a2;
                color: rgba(255,255,255,0.8);
                border-color: rgba(27,31,36,0.05);
                cursor: not-allowed;
            }

        #reset-chat-button {
            background-color: #cf222e;
            color: white;
        }

            #reset-chat-button:hover {
                background-color: #a40e26;
            }

        .scrape-url-controls {
            padding: 8px 16px 10px 16px;
            background-color: #ffffff;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            border-top: 1px solid #d0d7de;
        }

            .scrape-url-controls label {
                color: #57606a;
                cursor: pointer;
                user-select: none;
                vertical-align: middle;
            }

            .scrape-url-controls input[type="checkbox"] {
                vertical-align: middle;
                margin-top: 0;
                margin-right: 4px;
            }

        #scrape-status {
            font-size: 12px;
            margin-left: 10px;
            color: #0366d6;
            flex-grow: 1;
            text-align: right;
            min-height: 1.2em;
        }


        /* Markdown & Code Styling */
        .message-content pre {
            background-color: #f6f8fa;
            color: #24292f;
            padding: 16px;
            padding-top: 36px; /* More space for copy button to be clearly visible */
            border-radius: 6px;
            overflow-x: auto;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 85%;
            line-height: 1.45;
            border: 1px solid #d0d7de;
            margin-top: 0.5em;
            margin-bottom: 1em;
            position: relative; /* For copy button positioning */
        }

        .copy-code-button {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: #e1e4e8;
            color: #24292f;
            border: 1px solid #d0d7de;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.2s ease-in-out, background-color 0.1s;
            z-index: 10; /* Ensure it's above code content */
        }

        .message-content pre:hover .copy-code-button {
            opacity: 1; /* Show on pre hover */
        }

        .copy-code-button:hover {
            background-color: #f0f2f5;
            border-color: #c9d1d9;
        }

        .copy-code-button.copied {
            background-color: #2da44e; /* Green for success */
            color: white;
            border-color: #2c974b;
        }


        .message-content code:not(pre code) {
            background-color: rgba(175,184,193,0.2);
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 6px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }

        .message-content table {
            border-collapse: collapse;
            margin: 1em 0;
            display: block;
            width: max-content;
            max-width: 100%;
            overflow: auto;
            border: 1px solid #d0d7de;
        }

        .message-content th, .message-content td {
            border: 1px solid #d0d7de;
            padding: 6px 13px;
            text-align: left;
        }

        .message-content th {
            background-color: #f6f8fa;
            font-weight: 600;
        }

        .message-content blockquote {
            border-left: .25em solid #d0d7de;
            padding: 0 1em;
            color: #57606a;
            margin-left: 0;
            margin-right: 0;
            margin-top: 0.5em;
            margin-bottom: 1em;
        }

        .message-content hr {
            height: .25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }

        .message-content ul, .message-content ol {
            padding-left: 2em;
            margin-top: 0.5em;
            margin-bottom: 1em;
        }

        .message-content li {
            margin-bottom: 0.25em;
        }

        .message-content h1, .message-content h2, .message-content h3, .message-content h4, .message-content h5, .message-content h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }

        .message-content h1 {
            font-size: 2em;
            padding-bottom: .3em;
            border-bottom: 1px solid #d8dee4;
        }

        .message-content h2 {
            font-size: 1.5em;
            padding-bottom: .3em;
            border-bottom: 1px solid #d8dee4;
        }

        .message-content h3 {
            font-size: 1.25em;
        }

        .message-content h4 {
            font-size: 1em;
        }

        .message-content h5 {
            font-size: .875em;
        }

        .message-content h6 {
            font-size: .85em;
            color: #57606a;
        }

        mjx-container {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            display: block !important;
            margin: 1em 0 !important;
        }

        /* ----- Dark Theme ----- */
        .dark-theme {
            background-color: #1e1e1e;
            color: #fff;
        }

            .dark-theme .chat-container {
                border-color: #333;
                background-color: #282828;
            }

            .dark-theme .scrape-url-controls {
                background-color: #333;
                border-top: 1px solid #555;
            }

                .dark-theme .scrape-url-controls label {
                    color: #b3c2d1;
                }

            .dark-theme #scrape-status {
                color: #888;
            }

            .dark-theme .header-section {
                background-color: #333;
                border-bottom: 1px solid #555;
            }

                .dark-theme .header-section label:not(.collapsible-header-label) {
                    color: #fff;
                }

                .dark-theme .header-section select, .dark-theme .header-section textarea, .dark-theme .header-section input[type="text"] {
                    border-color: #555;
                    background-color: #333;
                    color: #fff;
                }

                    .dark-theme .header-section select:focus, .dark-theme .header-section textarea:focus, .dark-theme .header-section input[type="text"]:focus {
                        border-color: #0969da;
                        box-shadow: inset 0 1px 0 rgba(27,31,36,0.075), 0 0 0 3px rgba(9,105,218,0.3);
                    }

            .dark-theme .model-selector label {
                color: #fff;
            }

            .dark-theme .model-selector select, .dark-theme .model-selector input[type="text"] {
                border-color: #555;
                background-color: #333;
                color: #fff;
            }

            .dark-theme #update-ollama-url-button, .dark-theme #theme-toggle-button {
                background-color: #333;
                border-color: #555;
                color: #fff;
            }

                .dark-theme #update-ollama-url-button:hover, .dark-theme #theme-toggle-button:hover {
                    background-color: #444;
                    border-color: #666;
                }

            .dark-theme .system-prompt-area textarea {
                border-color: #555;
                background-color: #333;
                color: #fff;
            }

            .dark-theme .collapsible-header {
                color: #fff;
            }

                .dark-theme .collapsible-header:hover {
                    color: #9999CC;
                }

            .dark-theme .toggle-icon {
                color: #888;
            }

            .dark-theme .chat-messages {
                border-top: 1px solid #333;
            }

            .dark-theme .message-bubble {
                border-color: #333;
            }

                .dark-theme .message-bubble .message-sender {
                    color: #888;
                }

                .dark-theme .message-bubble .message-timestamp {
                    color: #888;
                }

                .dark-theme .message-bubble .message-content pre {
                    background-color: #333;
                    color: #eee;
                    border-color: #4a4a4a;
                }

            .dark-theme .copy-code-button {
                background-color: #4a4a4a;
                color: #ccc;
                border-color: #5a5a5a;
            }

                .dark-theme .copy-code-button:hover {
                    background-color: #5a5a5a;
                    border-color: #6a6a6a;
                }

                .dark-theme .copy-code-button.copied {
                    background-color: #2da44e;
                    color: white;
                    border-color: #2c974b;
                }

            .dark-theme .message-content code:not(pre code) {
                background-color: rgba(100,100,100,0.3);
            }

            .dark-theme .message-content th {
                background-color: #333;
            }

            .dark-theme .message-content td, .dark-theme .message-content th, .dark-theme .message-content table {
                border-color: #555;
            }

            .dark-theme .message-content blockquote {
                border-left-color: #555;
                color: #aaa;
            }

            .dark-theme .message-content hr {
                background-color: #555;
            }

            .dark-theme .message-content h1, .dark-theme .message-content h2 {
                border-bottom-color: #555;
            }

            .dark-theme .message-content h6 {
                color: #888;
            }

            .dark-theme .user-message {
                background-color: #3f3f3f;
                border-color: #444;
                color: #fff;
            }

            .dark-theme .ai-message {
                background-color: #282828;
                border-color: #333;
                color: #fff;
            }

                .dark-theme .ai-message em {
                    color: #888;
                }

            .dark-theme .collapsible-think-section {
                border-color: #444;
                background-color: #282828;
            }

                .dark-theme .collapsible-think-section .think-header {
                    background-color: #444;
                    color: #fff;
                    border-bottom-color: #555;
                }

                    .dark-theme .collapsible-think-section .think-header:hover {
                        background-color: #555;
                    }

                .dark-theme .collapsible-think-section .think-content {
                    background-color: #333;
                }

            .dark-theme #file-management-area {
                background-color: #333;
                border-color: #555;
                color: #fff;
            }

                .dark-theme #file-management-area.drag-over {
                    background-color: #444;
                    border-color: #666;
                }

                .dark-theme #file-management-area.disabled-drop-zone {
                    opacity: 1;
                    color: #888;
                }

            .dark-theme #drop-zone-instruction {
                color: #888;
            }

            .dark-theme #selected-files-container {
                border-color: #555;
            }

            .dark-theme .file-item {
                border-color: #555;
                background-color: #333;
                color: #fff;
            }

            .dark-theme .remove-file-btn {
                color: #cf222e;
            }

                .dark-theme .remove-file-btn:hover {
                    color: white;
                    background-color: #cf222e;
                }

            .dark-theme .chat-input-area {
                background-color: #333;
            }

                .dark-theme .chat-input-area textarea {
                    border-color: #555;
                    background-color: #333;
                    color: #fff;
                }

                    .dark-theme .chat-input-area textarea:focus {
                        border-color: #0969da;
                        box-shadow: inset 0 1px 0 rgba(27,31,36,0.075), 0 0 0 3px rgba(9,105,218,0.3);
                    }

                .dark-theme .chat-input-area button {
                    border-color: #555;
                    color: #fff;
                    background-color: #333;
                }

            .dark-theme #send-button {
                background-color: #2da44e;
                color: white;
            }

                .dark-theme #send-button:hover {
                    background-color: #2c974b;
                }

                .dark-theme #send-button:disabled {
                    background-color: #94d3a2;
                    color: rgba(255,255,255,0.8);
                }

            .dark-theme #reset-chat-button {
                background-color: #cf222e;
                color: white;
            }

                .dark-theme #reset-chat-button:hover {
                    background-color: #a40e26;
                }

            .dark-theme .scrape-url-controls {
                border-top-color: #555;
                color: #888;
            }

                .dark-theme .scrape-url-controls label {
                    color: #888;
                }
    </style>
</head>
<body id="body">

    <div class="chat-container">
        <!-- Header: Model Selection and API URL -->
        <div class="header-section model-selector">
            <label for="model-select">Модель:</label>
            <select id="model-select">
                <option value="">Загрузка моделей...</option>
            </select>
            <label id="api-label" for="ollama-url-input">API URL:</label>
            <input type="text" id="ollama-url-input">
            <button id="update-ollama-url-button" title="Обновить API URL и список моделей">↻</button>
            <button id="theme-toggle-button" title="Переключить Тёмный режим">☼</button>
        </div>

        <!-- Header: System Prompt -->
        <div class="header-section system-prompt-area">
            <div id="system-prompt-toggle" class="collapsible-header">
                <span class="collapsible-header-label">Системный Промпт (Опционально)</span>
                <span class="toggle-icon">[+]</span>
            </div>
            <div id="system-prompt-content" class="collapsible-content" style="display: none;">
                <textarea id="system-prompt-input" placeholder="Как пример, Ты полезный ассистент, который говорит как пират." rows="3"></textarea>
            </div>
        </div>

        <!-- Chat Messages Area -->
        <div class="chat-messages" id="chat-messages-area">
            <!-- Messages will be appended here -->
        </div>

        <!-- File Management Area -->
        <div id="file-management-area">
            <input type="file" id="file-input-hidden" style="display: none;" accept=".txt,.md,.json,.csv,.py,.js,.html,.css,.xml,text/*,application/pdf,image/*" multiple>
            <div id="selected-files-container">
                <!-- Selected file items will be appended here -->
            </div>
            <p id="drop-zone-instruction">Сбросте Файлы Сюда или Нажмите для Выгрузки</p>
        </div>

        <!-- Chat Input Area -->
        <div class="chat-input-area">
            <div class="textarea-wrapper">
                <div id="user-input-highlighter"></div>
                <textarea id="user-input" placeholder="Напишите ваше сообщение (Shift+Enter для новой строчки)..." rows="4"></textarea>
            </div>
            <div class="button-stack">
                <button id="send-button">Отправить</button>
                <button id="reset-chat-button">Очистить чат</button>
            </div>
        </div>

        <!-- URL Scraping Controls -->
        <div class="scrape-url-controls">
            <input type="checkbox" id="scrape-url-checkbox" name="scrape-url-checkbox">
            <label for="scrape-url-checkbox">Скрейпировать URL контент</label>
            <span id="scrape-status"></span>
        </div>
    </div>

    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>Prism.plugins.autoloader.languages_path = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/';</script>

    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            svg: { fontCache: 'global' },
            startup: {
                ready: () => {
                    console.log('MathJax готов.');
                    MathJax.startup.defaultReady();
                }
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- PDF.js Configuration -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
        } else {
            console.warn("pdf.js библиотека не загружена. PDF парсинг будет не доступен.");
        }
    </script>

    <!-- Main Application Logic -->
    <script>
        let OLLAMA_API_URL = "http://localhost:11434"; // Default API URL

        // DOM Element References
        const body = document.getElementById('body');
        const modelSelect = document.getElementById('model-select');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const systemPromptToggle = document.getElementById('system-prompt-toggle');
        const systemPromptContent = document.getElementById('system-prompt-content');
        const chatMessagesArea = document.getElementById('chat-messages-area');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const resetChatButton = document.getElementById('reset-chat-button');
        const apiLabel = document.getElementById('api-label');
        const ollamaUrlInput = document.getElementById('ollama-url-input');
        const updateOllamaUrlButton = document.getElementById('update-ollama-url-button');
        const fileManagementArea = document.getElementById('file-management-area');
        const fileInputHidden = document.getElementById('file-input-hidden');
        const selectedFilesContainer = document.getElementById('selected-files-container');
        const dropZoneInstruction = document.getElementById('drop-zone-instruction');
        const scrapeUrlCheckbox = document.getElementById('scrape-url-checkbox');
        const scrapeStatusElement = document.getElementById('scrape-status');
        const userInputHighlighter = document.getElementById('user-input-highlighter');
        const themeToggle = document.getElementById('theme-toggle-button');
        const prismLink = document.getElementById('prism-link');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const url = window.location.href;
        const urlParams = new URLSearchParams(url.split('?')[1]);

        // State Variables
        let isAwaitingResponse = false;
        let currentAiMessageElement = null;
        let currentAiMessageContentDiv = null;
        let attachedFiles = [];
        let userScrolledUp = false;
        let currentStreamController = null; // To abort fetch streams
        let isSavingSystemPrompt = false;

        // Constants
        const THINK_TAG_PLACEHOLDER_PREFIX = "%%THINK_BLOCK_ID_";
        const THINK_TAG_PLACEHOLDER_SUFFIX = "%%";

        if (prefersDark) {
            document.body.classList.add('dark-theme');
            prismLink.href = 'https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism-dark.min.css';
        }

        try {
            systemPromptInput.value = localStorage.getItem('systemPrompt') || "";
            conversationHistoryUITemp = conversationHistoryUI();
            conversationHistoryUITemp.forEach((item) => {
                let messageTemp = convertToDOM(item)[0];
                console.log("converting", item, messageTemp);
                chatMessagesArea.appendChild(messageTemp);
            });
            // chatMessagesArea.appendChild
        } catch {} 

        marked.setOptions({
            highlight: function (code, lang) {
                const language = lang || 'markup';
                if (Prism.languages[language]) {
                    try { return Prism.highlight(code, Prism.languages[language], language); }
                    catch (e) { console.warn(`Prism подсветка не удалась для языка "${language}":`, e); return code; }
                } else {
                    Prism.plugins.autoloader.loadLanguages(language, () => { });
                    return code;
                }
            },
            gfm: true, breaks: true, pedantic: false, smartLists: true, smartypants: false, headerIds: false, mangle: false
        });

        function escapeHTML(str) {
            if (!str) return '';
            return str.replace(/[&<>'"]/g, tag => ({
                '&': '&', '<': '<', '>': '>', "'": '\'', '"': '"'
            }[tag] || tag));
        }

        if (!RegExp.escape) {
            RegExp.escape = function (s) { return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); };
        }

        async function fetchModels() {
            modelSelect.innerHTML = `<option value="">Загрузка моделей из ${escapeHTML(OLLAMA_API_URL)}...</option>`;
            try {
                const response = await fetch(`${OLLAMA_API_URL}/api/tags`);
                if (!response.ok) {
                    let errorText = `HTTP error! Status: ${response.status}`;
                    try { const errorBody = await response.text(); errorText += ` - ${errorBody.substring(0, 100)}${errorBody.length > 100 ? '...' : ''}`; } catch { }
                    throw new Error(errorText);
                }
                const data = await response.json();
                await populateModelSelector(data.models || []);
            } catch (error) {
                console.error("Ошибка извлечения моделей:", error);
                modelSelect.innerHTML = `<option value="">Ошибка загрузки моделей. Проверте URL и Ollama статус.</option>`;
                ollamaUrlInput.style.borderColor = '#cf222e';
                alert(`Не удалалось извлечь модели из ${OLLAMA_API_URL}:\n${error.message}\n\nПожалуйста убедитесь, что Ollama запущена, и, что API URL правильный (включая http/https).`);
            }
        }

        function populateModelSelector(models) {
            modelSelect.innerHTML = '';
            ollamaUrlInput.style.borderColor = '';
            if (models.length === 0) {
                modelSelect.innerHTML = '<option value="">Моделей не найдено на этом URL</option>';
                return;
            }
            models.sort((a, b) => a.name.localeCompare(b.name));
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.name;
                option.textContent = model.name;
                modelSelect.appendChild(option);
            });
        }

        function addCopyButtonsToCodeBlocks(parentElement) {
            if (!parentElement) return;
            parentElement.querySelectorAll('pre').forEach(preElement => {
                if (preElement.querySelector('.copy-code-button')) {
                    return; // Avoid adding multiple buttons
                }
                const copyButton = document.createElement('button');
                copyButton.textContent = 'Скопировать';
                copyButton.className = 'copy-code-button';
                copyButton.title = 'Скопировать код в буфер обмена';
                copyButton.addEventListener('click', async () => {
                    const codeElement = preElement.querySelector('code');
                    if (codeElement) {
                        const codeToCopy = codeElement.textContent || "";
                        try {
                            await navigator.clipboard.writeText(codeToCopy);
                            copyButton.textContent = 'Скопировано!';
                            copyButton.classList.add('copied');
                            setTimeout(() => {
                                copyButton.textContent = 'Копировать';
                                copyButton.classList.remove('copied');
                            }, 2000);
                        } catch (err) {
                            console.error('Не удалось скопировать код: ', err);
                            copyButton.textContent = 'Error';
                            setTimeout(() => { copyButton.textContent = 'Скопировать'; }, 2000);
                        }
                    }
                });
                preElement.appendChild(copyButton);
            });
        }

        function removeMessage(messageId) {
            const messageBubble = document.getElementById(messageId);
            if (messageBubble) {
                messageBubble.remove();

                // Optional: remove from conversation history
                removeMessageFromHistory(messageId);
                removeMessageFromUIHistory(messageId);
            }
        }

        function removeMessageFromHistory(messageId) {
            let conversationHistoryTemp = conversationHistory();
            conversationHistoryTemp = conversationHistoryTemp.filter(message => {
                return message.id !== messageId;
            });

            // update localStorage:
            localStorage.setItem('conversationHistory', JSON.stringify(conversationHistoryTemp));
        }

        function removeMessageFromUIHistory(messageId) {
            let conversationHistoryTemp = conversationHistoryUI();
            conversationHistoryTemp = conversationHistoryTemp.filter(message => {
                let messageElement = convertToDOM(message)[0];
                if (messageElement) {
                    return messageElement.id !== messageId;
                }
                return true;
            });

            // update localStorage:
            localStorage.setItem('conversationHistoryUI', JSON.stringify(conversationHistoryTemp));
        }

        function displayMessage(sender, mainText, messageId, scrapedInfoSummary = null, isStreaming = false, attachedFilenamesArray = null) {
            const messageBubble = document.createElement('div');
            messageBubble.classList.add('message-bubble', sender.toLowerCase() + '-message');
            messageBubble.id = messageId;

            const senderDiv = document.createElement('div');
            senderDiv.classList.add('message-sender');
            senderDiv.textContent = sender === 'User' ? 'You' : (modelSelect.value.split(':')[0] || 'AI');
            messageBubble.appendChild(senderDiv);

            if (sender === 'User' && attachedFilenamesArray && attachedFilenamesArray.length > 0) {
                const attachmentNoteDiv = document.createElement('div');
                attachmentNoteDiv.classList.add('attachment-note');
                const filenamesString = attachedFilenamesArray.map(name => `<code>${escapeHTML(name)}</code>`).join(', ');
                attachmentNoteDiv.innerHTML = `Прикрепленные файлы: ${filenamesString}`;
                messageBubble.appendChild(attachmentNoteDiv);
            }

            const deleteButton = document.createElement('button');
            deleteButton.classList.add('remove-message-btn');
            deleteButton.innerHTML = '×';
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                console.log(messageBubble.id);
                const messageId = messageBubble.id;
                removeMessage(messageId);
            });
            messageBubble.appendChild(deleteButton);

            const contentDiv = document.createElement('div');
            contentDiv.classList.add('message-content');

            if (isStreaming && sender === 'AI') {
                contentDiv.innerHTML = "<em>Печатает...</em>";
                currentAiMessageElement = messageBubble;
                currentAiMessageContentDiv = contentDiv;
                if (scrapeStatusElement) scrapeStatusElement.textContent = "";
            } else {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = marked.parse(mainText || '');
                while (tempDiv.firstChild) contentDiv.appendChild(tempDiv.firstChild);
                Prism.highlightAllUnder(contentDiv);
                addCopyButtonsToCodeBlocks(contentDiv);
                if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                    MathJax.typesetPromise([contentDiv]).catch(err => console.warn(`MathJax processing error for ${sender} message:`, err));
                }
            }
            messageBubble.appendChild(contentDiv);

            if (sender === 'User' && scrapedInfoSummary && scrapedInfoSummary.trim() !== "") {
                const scrapedInfoContainer = document.createElement('div');
                scrapedInfoContainer.classList.add('scraped-info-summary');
                scrapedInfoContainer.innerHTML = marked.parse(scrapedInfoSummary.trim());
                Prism.highlightAllUnder(scrapedInfoContainer);
                addCopyButtonsToCodeBlocks(scrapedInfoContainer);
                messageBubble.appendChild(scrapedInfoContainer);
            }

            const timestampDiv = document.createElement('div');
            timestampDiv.classList.add('message-timestamp');
            timestampDiv.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            messageBubble.appendChild(timestampDiv);

            chatMessagesArea.appendChild(messageBubble);
            if (sender === 'User') {
                saveMessageUI(messageBubble);
            }
            scrollToBottom();
            return { messageBubble, contentDiv };
        }

        function processThinkTagsInMarkdown(markdown) {
            const thinkBlocks = [];
            let blockIdCounter = 0;
            const processedMarkdown = markdown.replace(/<think>([\s\S]*?)<\/think>/g, (match, thinkContent) => {
                const currentId = blockIdCounter++;
                thinkBlocks.push({ id: `think-${Date.now()}-${currentId}`, rawContent: thinkContent.trim() });
                return `${THINK_TAG_PLACEHOLDER_PREFIX}${thinkBlocks[thinkBlocks.length - 1].id}${THINK_TAG_PLACEHOLDER_SUFFIX}`;
            });
            return { processedMarkdown, thinkBlocks };
        }

        function renderThinkBlocksHTML(contentDiv, thinkBlocks) {
            if (!thinkBlocks || thinkBlocks.length === 0 || !contentDiv) return;
            let html = contentDiv.innerHTML;
            thinkBlocks.forEach(block => {
                const placeholder = `${THINK_TAG_PLACEHOLDER_PREFIX}${block.id}${THINK_TAG_PLACEHOLDER_SUFFIX}`;
                const thinkSectionHtml = `
                            <div class="collapsible-think-section">
                                <div class="think-header" data-think-block-id="${block.id}">
                                    <span>Мысли ИИ</span> <span class="toggle-icon">[+]</span>
                                </div>
                                <div class="think-content" id="think-content-${block.id}" style="display:none;">
                                    ${marked.parse(block.rawContent)}
                                </div>
                            </div>`;
                const placeholderRegExp = new RegExp(RegExp.escape(placeholder), 'g');
                html = html.replace(placeholderRegExp, thinkSectionHtml);
            });
            contentDiv.innerHTML = html;
        }

        function addThinkBlockListeners(parentElement) {
            if (!parentElement) return;
            parentElement.querySelectorAll('.think-header').forEach(header => {
                if (header.dataset.listenerAttached === 'true') return;
                header.addEventListener('click', () => {
                    const blockId = header.dataset.thinkBlockId;
                    const thinkContentElement = parentElement.querySelector(`#think-content-${blockId}`);
                    const toggleIcon = header.querySelector('.toggle-icon');
                    if (thinkContentElement && toggleIcon) {
                        const isHidden = thinkContentElement.style.display === 'none';
                        thinkContentElement.style.display = isHidden ? 'block' : 'none';
                        toggleIcon.textContent = isHidden ? '[-]' : '[+]';
                        if (isHidden) {
                            Prism.highlightAllUnder(thinkContentElement);
                            addCopyButtonsToCodeBlocks(thinkContentElement);
                            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                                MathJax.typesetPromise([thinkContentElement]).catch(err => console.warn("MathJax (think block expansion):", err));
                            }
                        }
                    }
                });
                header.dataset.listenerAttached = 'true';
            });
        }

        function updateStreamingMessage(externalThinkContent) {
            // Guard: Only update if still awaiting response and the content div exists
            if (!isAwaitingResponse || !currentAiMessageContentDiv) return;

            const accumulatedMainContent = currentAiMessageContentDiv.dataset.rawMarkdown || "";
            if (currentAiMessageContentDiv.innerHTML.includes("<em>Печатает...</em>")) {
                currentAiMessageContentDiv.innerHTML = '';
            }

            let combinedHtmlToRender = "";
            let mainContentThinkBlocks = [];

            if (externalThinkContent && externalThinkContent.trim() !== "") {
                const externalThinkBlockId = `ext-think-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
                combinedHtmlToRender += `
                            <div class="collapsible-think-section">
                                <div class="think-header" data-think-block-id="${externalThinkBlockId}">
                                    <span>Мысли ИИ (Модель Думает)</span> <span class="toggle-icon">[+]</span>
                                </div>
                                <div class="think-content" id="think-content-${externalThinkBlockId}" style="display:none;">
                                    ${marked.parse(externalThinkContent)}
                                </div>
                            </div>`;
            }

            if (accumulatedMainContent) {
                const { processedMarkdown, thinkBlocks } = processThinkTagsInMarkdown(accumulatedMainContent);
                mainContentThinkBlocks = thinkBlocks;
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = marked.parse(processedMarkdown);
                const mainContentContainer = document.createElement('div');
                while (tempDiv.firstChild) mainContentContainer.appendChild(tempDiv.firstChild);
                combinedHtmlToRender += mainContentContainer.innerHTML;
            }

            currentAiMessageContentDiv.innerHTML = combinedHtmlToRender;
            renderThinkBlocksHTML(currentAiMessageContentDiv, mainContentThinkBlocks);
            addThinkBlockListeners(currentAiMessageContentDiv);
            Prism.highlightAllUnder(currentAiMessageContentDiv);
            addCopyButtonsToCodeBlocks(currentAiMessageContentDiv);
            scrollToBottom();
        }

        function finalizeAiMessage(externalThinkContent, aiMessageBubble) {
            // Guard: Only finalize if the content div exists (isAwaitingResponse might have been reset)
            if (currentAiMessageContentDiv) {
                const finalRawMainContent = currentAiMessageContentDiv.dataset.rawMarkdown || "";
                let finalCombinedHtml = "";
                let finalMainContentThinkBlocks = [];

                if (externalThinkContent && externalThinkContent.trim() !== "") {
                    const externalThinkBlockId = `ext-think-final-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
                    finalCombinedHtml += `
                                <div class="collapsible-think-section">
                                    <div class="think-header" data-think-block-id="${externalThinkBlockId}">
                                        <span>Мысли ИИ (Модель Думает)</span> <span class="toggle-icon">[+]</span>
                                    </div>
                                    <div class="think-content" id="think-content-${externalThinkBlockId}" style="display:none;">
                                        ${marked.parse(externalThinkContent)}
                                    </div>
                                </div>`;
                }

                if (finalRawMainContent) {
                    const { processedMarkdown, thinkBlocks } = processThinkTagsInMarkdown(finalRawMainContent);
                    finalMainContentThinkBlocks = thinkBlocks;
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = marked.parse(processedMarkdown);
                    const mainContentContainer = document.createElement('div');
                    while (tempDiv.firstChild) mainContentContainer.appendChild(tempDiv.firstChild);
                    finalCombinedHtml += mainContentContainer.innerHTML;
                }

                currentAiMessageContentDiv.innerHTML = finalCombinedHtml;
                renderThinkBlocksHTML(currentAiMessageContentDiv, finalMainContentThinkBlocks);
                addThinkBlockListeners(currentAiMessageContentDiv);
                Prism.highlightAllUnder(currentAiMessageContentDiv);
                addCopyButtonsToCodeBlocks(currentAiMessageContentDiv);
                if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                    MathJax.typesetPromise([currentAiMessageContentDiv]).catch(err => console.warn("MathJax (final message processing):", err));
                }
                delete currentAiMessageContentDiv.dataset.rawMarkdown;
            }
            // These are reset here if stream ended naturally, or by resetChat if aborted.
            currentAiMessageElement = null;
            currentAiMessageContentDiv = null;
            userScrolledUp = false;
            scrollToBottom();
            saveMessageUI(aiMessageBubble);
        }


        function extractUrls(text) {
            if (!text) return [];
            const urlRegex = /\b(https?:\/\/)(?:www\.)?([-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6})\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/gi;
            const urls = text.match(urlRegex);
            const validUrls = urls ? urls.filter(url => !url.endsWith('.') || /\.[a-zA-Z]{2,}$/.test(url)) : [];
            return validUrls.length > 0 ? Array.from(new Set(validUrls)) : [];
        }
        
        function stringToHTML(str) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(str, 'text/html');
            return doc;
        }

        function convertToDOM(htmlString) {
            const targetDiv = document.createElement('div');
          
            try {
                targetDiv.innerHTML = htmlString;
                return Array.from(targetDiv.childNodes);
            } catch (error) {
                console.error("Parsing error:", error);
                return [];
            }
        }

        function extractMeaningfulText(htmlString, baseUrl) {
            if (!htmlString || typeof htmlString !== 'string') return "[Invalid HTML input provided]";
            try {
                const doc = stringToHTML(htmlString);
                let base = doc.querySelector('base[href]');
                if (!base) { base = doc.createElement('base'); base.href = baseUrl; doc.head?.appendChild(base); }

                const selectorsToRemove = 'script, style, noscript, iframe, header, footer, nav, aside, form, [aria-hidden="true"], .noprint, link[rel="stylesheet"], noscript';
                doc.querySelectorAll(selectorsToRemove).forEach(el => el.remove());

                let contentNode = doc.querySelector('main') || doc.querySelector('article') || doc.querySelector('.main-content') || doc.querySelector('#main') || doc.querySelector('.entry-content') || doc.querySelector('.post-content') || doc.querySelector('div[role="main"]');
                if (!contentNode) { console.warn("Could not find specific main content node, using document.body for URL:", baseUrl); contentNode = doc.body; if (!contentNode) return "[Could not parse body content]"; }

                let text = '';
                const maxChars = 15000;

                function getTextNodes(node) {
                    if (!node || text.length >= maxChars) return;
                    if (node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE) return;
                    if (node.nodeType === Node.TEXT_NODE) {
                        const nodeText = node.textContent.trim(); if (nodeText) text += nodeText + ' ';
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        const tagName = node.tagName.toUpperCase();
                        const blockElements = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'LI', 'BLOCKQUOTE', 'TD', 'TH', 'DIV', 'ARTICLE', 'SECTION', 'PRE', 'HR', 'TABLE', 'UL', 'OL'];
                        if (blockElements.includes(tagName) && text.length > 0 && !text.endsWith('\n\n')) text += '\n\n';
                        else if (tagName === 'BR' && !text.endsWith('\n')) text += '\n';
                        if (tagName === 'A' && node.href) {
                            const linkText = node.textContent.trim(); const absoluteUrl = new URL(node.getAttribute('href'), base.href).href;
                            if (linkText && linkText !== absoluteUrl) text += `${linkText} [${absoluteUrl}] `;
                            else if (!linkText) text += `[${absoluteUrl}] `; else text += `${linkText} `;
                        } else if (tagName === 'IMG' && node.alt) {
                            text += `[Image: ${node.alt.trim()}] `;
                        } else if (tagName !== 'A') { node.childNodes.forEach(getTextNodes); }
                        if (blockElements.includes(tagName) && !text.endsWith('\n\n')) text += '\n\n';
                    }
                }
                getTextNodes(contentNode);
                text = text.replace(/(\t| )+/g, ' ').replace(/(\n\s*){3,}/g, '\n\n').trim();
                if (text.length > maxChars) text = text.substring(0, maxChars) + '... [Content Truncated]';
                return text;
            } catch (error) { console.error("Error parsing HTML for URL:", baseUrl, error); return `[Error parsing HTML content: ${escapeHTML(error.message)}]`; }
        }

        function saveMessage(message) {
            let conversationHistoryTemp = conversationHistory();
            conversationHistoryTemp.push(message);
            localStorage.setItem('conversationHistory', JSON.stringify(conversationHistoryTemp));
        }

        function saveMessageUI(message) {
            let conversationHistoryTemp = conversationHistoryUI();
            conversationHistoryTemp.push(message.outerHTML);
            localStorage.setItem('conversationHistoryUI', JSON.stringify(conversationHistoryTemp));
        }

        function conversationHistory() {
            let conversationHistoryTemp = [];
            try {
                conversationHistoryTemp = JSON.parse(localStorage.getItem('conversationHistory')) || [];
            } catch {}
            return conversationHistoryTemp
        }

        function conversationHistoryUI() {
            let conversationHistoryTemp = [];
            try {
                conversationHistoryTemp = JSON.parse(localStorage.getItem('conversationHistoryUI')) || [];
            } catch {}
            return conversationHistoryTemp
        }

        function saveSystemPrompt(value) {
            if (!isSavingSystemPrompt) {
                isSavingSystemPrompt = true;
                
                const savedValue = localStorage.getItem('systemPrompt');

                if (value !== savedValue && value !== '') {
                    localStorage.setItem('systemPrompt', value);
                } else if (value === '') {
                    localStorage.removeItem('systemPrompt');
                }
                
                isSavingSystemPrompt = false;
            }
        }

        systemPromptInput.addEventListener('input', () => saveSystemPrompt(systemPromptInput.value.trim()));

        function generateUniqueId() {
            return 'message-' + Math.random().toString(36).substring(2, 15);
        }

        async function sendMessage() {
            userScrolledUp = false;
            const messageText = userInput.value.trim();
            const messageId = generateUniqueId();
            const messageIdAi = generateUniqueId() + '-ai';
            const selectedModel = modelSelect.value;
            const systemPrompt = systemPromptInput.value.trim();
            const shouldScrapeUrls = scrapeUrlCheckbox.checked;
            let currentExternalThinkContent = "";

            let scrapedUrlContentForApi = ""; let scrapedPreambleForUserDisplay = "";
            let urlsToScrape = []; let scrapedCount = 0; let failedScrapes = 0;

            if (messageText) urlsToScrape = extractUrls(messageText);

            if (shouldScrapeUrls && urlsToScrape.length > 0) {
                scrapeStatusElement.textContent = `Нашло ${urlsToScrape.length} URL(s). Скрейпинг...`;
                sendButton.disabled = true;
                const MAX_CONCURRENT_SCRAPES = 3; let activeScrapes = 0;
                const scrapePromises = []; const scrapeQueue = [...urlsToScrape];
                const processQueue = async () => {
                    while (scrapeQueue.length > 0 && activeScrapes < MAX_CONCURRENT_SCRAPES) {
                        activeScrapes++; const url = scrapeQueue.shift();
                        scrapePromises.push((async () => {
                            const displayUrl = url.length > 60 ? url.substring(0, 57) + '...' : url;
                            scrapeStatusElement.textContent = `Скрейпинг (${scrapedCount + failedScrapes + 1}/${urlsToScrape.length}): ${escapeHTML(displayUrl)}`;
                            let extractedContent = ''; let success = false; let detailMsg = ''; let contentType = 'unknown';
                            try {
                                const proxyFetchUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                                const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 20000);
                                const response = await fetch(proxyFetchUrl, { headers: { 'Accept': 'text/html,text/plain,application/json,application/xml' }, signal: controller.signal });
                                clearTimeout(timeoutId); contentType = response.headers.get("content-type")?.split(';')[0] || 'unknown';
                                if (!response.ok) throw new Error(`Proxy fetch failed: ${response.status} ${response.statusText}`);
                                if (contentType.includes("text/html")) {
                                    const htmlContent = await response.text(); extractedContent = extractMeaningfulText(htmlContent, url);
                                    if (extractedContent.startsWith('[Error')) { success = false; detailMsg = extractedContent; }
                                    else if (!extractedContent) { success = false; detailMsg = "Вытащено пустое содержимое"; }
                                    else { success = true; detailMsg = `Парсировано ${extractedContent.length} символов`; }
                                } else if (contentType.includes("text/plain") || contentType.includes("application/json") || contentType.includes("application/xml") || contentType.includes("text/xml")) {
                                    extractedContent = await response.text(); const maxCharsText = 20000;
                                    if (extractedContent.length > maxCharsText) extractedContent = extractedContent.substring(0, maxCharsText) + `... [${contentType.split('/')[1]} Content Truncated]`;
                                    success = true; detailMsg = `Прочитано ${extractedContent.length} символов`;
                                    if (contentType.includes("application/json")) { try { JSON.parse(extractedContent); } catch (jsonError) { console.warn("Scraped JSON is invalid:", jsonError, url); detailMsg += " (некоректная JSON структура)"; } }
                                } else { detailMsg = `Пропущено (Неподдерживаемы тип: ${escapeHTML(contentType)})`; success = false; }
                            } catch (error) {
                                console.warn(`Error scraping URL ${url}:`, error);
                                detailMsg = `Провалилось (${escapeHTML(error.name === 'AbortError' ? 'Timeout' : error.message || "Unknown fetch error")})`; success = false;
                            } finally {
                                activeScrapes--;
                                if (success && extractedContent) {
                                    scrapedUrlContentForApi += `\n\n--- Контент из ${escapeHTML(url)} ---\n${extractedContent}\n--- Конец контент из ${escapeHTML(url)} ---\n`;
                                    scrapedPreambleForUserDisplay += `\n- **Успешно:** \`${escapeHTML(url)}\` (${detailMsg})`; scrapedCount++;
                                } else {
                                    scrapedPreambleForUserDisplay += `\n- **Провально:** \`${escapeHTML(url)}\` (${detailMsg})`; failedScrapes++;
                                }
                                if (scrapeQueue.length > 0 || activeScrapes > 0) processQueue();
                            }
                        })()
                        );
                    }
                };
                processQueue(); await Promise.all(scrapePromises);
                scrapeStatusElement.textContent = `Скрейпинг завершён: ${scrapedCount} удачно, ${failedScrapes} провалилось/пропущено.`;
                if (!isAwaitingResponse) sendButton.disabled = false;
                scrapedPreambleForUserDisplay = scrapedPreambleForUserDisplay.trim();
                if (scrapedPreambleForUserDisplay) scrapedPreambleForUserDisplay = `**Результат URL Скрейпинга:**${scrapedPreambleForUserDisplay}`;
            } else if (shouldScrapeUrls && urlsToScrape.length === 0 && messageText) {
                scrapeStatusElement.textContent = "Не найдено URL в сообщении для скрейпинга.";
            } else if (!shouldScrapeUrls) { scrapeStatusElement.textContent = ""; }

            if ((!messageText && attachedFiles.length === 0 && !scrapedUrlContentForApi) || !selectedModel || isAwaitingResponse) {
                if (!selectedModel) { alert("Пожалуйста выберите модель."); modelSelect.focus(); }
                if (isAwaitingResponse) console.log("Уже ожидается ответ.");
                if (!messageText && attachedFiles.length === 0 && !scrapedUrlContentForApi.trim()) {
                    if (!isAwaitingResponse) { sendButton.disabled = false; userInput.disabled = false; fileManagementArea.classList.remove('disabled-drop-zone'); }
                    return;
                }
            }

            isAwaitingResponse = true; sendButton.disabled = true; userInput.disabled = true; fileManagementArea.classList.add('disabled-drop-zone');
            displayMessage("Пользователь", messageText, messageId, scrapedPreambleForUserDisplay || null, false, attachedFiles.map(f => f.name));
            userInput.value = ''; adjustTextareaHeight(); updateInputHighlighting();

            const aiMessageElements = displayMessage("ИИ", "<em>Печатает...</em>", messageId, null, true);
            currentAiMessageContentDiv = aiMessageElements.contentDiv; currentAiMessageContentDiv.dataset.rawMarkdown = "";

            let userMessageForApi = "";
            if (scrapedUrlContentForApi) userMessageForApi += `Пользователь предоставил URL с следующим вытащенным контентом:\n${scrapedUrlContentForApi}\n--- Конец Вытащенного URL Контента ---\n\n`;
            if (messageText) userMessageForApi += `Пользователь написал сообщение:\n${messageText}\n`;
            else if (scrapedUrlContentForApi) userMessageForApi += `Пользователь написал сообщение:\n(Нет написанного сообщения; контант сверху был из URL.)\n`;

            const imagesForApi = []; let filePreambleForApi = ""; let textFileContentsForApi = "";
            if (attachedFiles.length > 0) {
                filePreambleForApi = "Пользователь также прикрепил следующие файлы (контент включён для text-based):\n";
                for (const file of attachedFiles) {
                    const safeFilename = escapeHTML(file.name); filePreambleForApi += `- "${safeFilename}" (Type: ${file.type || 'unknown'})\n`;
                    if (file.type.startsWith('image/')) { const base64Data = file.content.split(',')[1]; if (base64Data) imagesForApi.push(base64Data); }
                    else textFileContentsForApi += `\n\n--- Содержимое файла "${safeFilename}" ---\n\`\`\`\n${file.content}\n\`\`\`\n--- Конец содержимого файла "${safeFilename}" ---\n`;
                }
                userMessageForApi += `\n\n${filePreambleForApi}${textFileContentsForApi}`;
            }

            if (!userMessageForApi.trim() && imagesForApi.length === 0) {
                console.error("Attempted to send an empty message after processing. Aborting.");
                isAwaitingResponse = false; sendButton.disabled = false; userInput.disabled = false; fileManagementArea.classList.remove('disabled-drop-zone');
                scrapeStatusElement.textContent = "Ничего допустимого для отправки."; finalizeAiMessage(currentExternalThinkContent, aiMessageElements.messageBubble);
                if (currentAiMessageContentDiv) currentAiMessageContentDiv.innerHTML = marked.parse("**Error:** Обработка привела к пустому сообщению. Ничего не отправлено.");
                else displayMessage("AI", "**Error:** Обработка привела к пустому сообщению. Ничего не отправлено.", null);
                return;
            }

            const messagesForApiPayload = [];
            if (systemPrompt) messagesForApiPayload.push({ role: "system", content: systemPrompt });
            messagesForApiPayload.push(...conversationHistory());
            const currentUserMessagePayload = { role: "user", content: userMessageForApi.trim() };
            if (imagesForApi.length > 0) currentUserMessagePayload.images = imagesForApi;
            messagesForApiPayload.push(currentUserMessagePayload);

            currentStreamController = new AbortController(); // Create a new controller for this request
            const signal = currentStreamController.signal;

            try {
                const requestBody = { model: selectedModel, messages: messagesForApiPayload, stream: true };
                console.log("Sending API Request:", JSON.stringify(requestBody, (k, v) => (k === 'images' && Array.isArray(v)) ? [`<${v.length} image(s)>`] : (k === 'content' && typeof v === 'string' && v.length > 500) ? v.substring(0, 250) + '...[truncated]...' + v.substring(v.length - 250) : v, 2));
                const response = await fetch(`${OLLAMA_API_URL}/api/chat`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody), signal }); // Pass the signal
                if (!response.ok) {
                    let errorBody = await response.text(); console.error(`API Error Response (${response.status}):`, errorBody);
                    let detail = errorBody.substring(0, 200); try { const parsedError = JSON.parse(errorBody); if (parsedError.error) detail = parsedError.error; } catch { }
                    throw new Error(`API request failed: ${response.status} ${response.statusText}. ${detail ? `Details: ${detail}` : ''}`);
                }

                let historyUserContent = messageText || "(Нет написанного сообщения)";
                if (attachedFiles.length > 0) historyUserContent = `(Прикреплено: ${attachedFiles.map(f => `\`${escapeHTML(f.name)}\``).join(', ')}) ${historyUserContent}`;
                if (scrapedPreambleForUserDisplay && scrapedCount > 0) historyUserContent += `\n*(Скрейпировано ${scrapedCount} URL)*`;
                saveMessage({ role: "user", content: historyUserContent.trim(), id: messageId });

                const reader = response.body.getReader(); const decoder = new TextDecoder(); let aiResponseContent = "";
                if (currentAiMessageContentDiv && currentAiMessageContentDiv.innerHTML.includes("<em>Печатает...</em>")) { currentAiMessageContentDiv.innerHTML = ''; currentAiMessageContentDiv.dataset.rawMarkdown = ''; }

                while (true) {
                    const { done, value } = await reader.read(); if (done) break;
                    const chunk = decoder.decode(value, { stream: true }); const lines = chunk.split('\n').filter(line => line.trim() !== '');
                    for (const line of lines) {
                        try {
                            const parsedLine = JSON.parse(line); let hasNewDataToRender = false;
                            if (parsedLine.message && typeof parsedLine.message.thinking === 'string') { currentExternalThinkContent = parsedLine.message.thinking.trim(); hasNewDataToRender = true; }
                            if (parsedLine.message && typeof parsedLine.message.content === 'string') {
                                const contentPiece = parsedLine.message.content; aiResponseContent += contentPiece;
                                currentAiMessageContentDiv.dataset.rawMarkdown = (currentAiMessageContentDiv.dataset.rawMarkdown || "") + contentPiece; hasNewDataToRender = true;
                            }
                            if (hasNewDataToRender) updateStreamingMessage(currentExternalThinkContent);
                        } catch (e) { console.warn("Failed to parse JSON line from stream:", line, e); }
                    }
                }
                saveMessage({ role: "assistant", content: aiResponseContent, id: messageIdAi });
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Fetch stream aborted by user reset.'); // This is expected during a reset.
                    // The finalizeAiMessage call in the finally block will handle cleanup.
                    // No need to display an error message in the chat UI for this.
                } else {
                    console.error("Error during sendMessage API call or processing:", error);
                    const errorMessage = `**Error:** ${escapeHTML(error.message) || "An unknown error occurred during the request."}`;
                    if (currentAiMessageContentDiv) {
                        currentAiMessageContentDiv.innerHTML = marked.parse(errorMessage); currentAiMessageContentDiv.dataset.rawMarkdown = errorMessage;
                        Prism.highlightAllUnder(currentAiMessageContentDiv); addCopyButtonsToCodeBlocks(currentAiMessageContentDiv);
                    } else { displayMessage("AI", errorMessage, null); }
                    if (scrapeStatusElement) scrapeStatusElement.textContent = "Ошибка во время ответа ИИ.";
                }
            } finally {
                finalizeAiMessage(currentExternalThinkContent, aiMessageElements.messageBubble); // Always call to cleanup current message element
                currentStreamController = null; // Clear the controller
                clearAllAttachedFiles();
                // Only reset UI if isAwaitingResponse is still true (i.e., not reset by resetChat)
                if (isAwaitingResponse) {
                    isAwaitingResponse = false;
                    sendButton.disabled = false; userInput.disabled = false; fileManagementArea.classList.remove('disabled-drop-zone');
                    userInput.focus();
                }
            }
        }

        function renderAttachedFilesUI() {
            selectedFilesContainer.innerHTML = '';
            if (attachedFiles.length > 0) {
                dropZoneInstruction.style.display = 'none'; selectedFilesContainer.style.display = 'block';
                attachedFiles.forEach(file => {
                    const fileItem = document.createElement('div'); fileItem.classList.add('file-item');
                    const fileNameSpan = document.createElement('span'); fileNameSpan.textContent = file.name; fileNameSpan.title = `${file.name} (${file.type || 'unknown type'})`;
                    const removeBtn = document.createElement('button'); removeBtn.classList.add('remove-file-btn'); removeBtn.innerHTML = '×'; removeBtn.title = `Убрать ${file.name}`; removeBtn.dataset.fileId = file.id;
                    removeBtn.onclick = (e) => { e.stopPropagation(); removeSpecificFile(file.id); };
                    fileItem.appendChild(fileNameSpan); fileItem.appendChild(removeBtn); selectedFilesContainer.appendChild(fileItem);
                });
            } else { dropZoneInstruction.style.display = 'block'; selectedFilesContainer.style.display = 'none'; }
            fileManagementArea.style.paddingBottom = attachedFiles.length > 0 ? '5px' : '10px';
        }
        async function extractTextFromPdf(arrayBuffer) {
            if (typeof pdfjsLib === 'undefined') return "[PDF.js library not loaded. Cannot extract text.]";
            try {
                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer }); const pdf = await loadingTask.promise; let fullText = '';
                const maxPagesToProcess = 50; const numPages = Math.min(pdf.numPages, maxPagesToProcess);
                dropZoneInstruction.textContent = `Обработка PDF: 0/${numPages} страниц...`;
                for (let i = 1; i <= numPages; i++) {
                    const page = await pdf.getPage(i); const textContent = await page.getTextContent();
                    fullText += textContent.items.map(item => item.str).join(' ') + '\n\n';
                    dropZoneInstruction.textContent = `Обработка PDF: ${i}/${numPages} страниц...`; page.cleanup();
                }
                if (pdf.numPages > maxPagesToProcess) fullText += `\n\n[Обработка PDF остановилась после ${maxPagesToProcess} страниц. Всего страниц: ${pdf.numPages}]`;
                dropZoneInstruction.textContent = 'Сбросте Файлы Сюда или Нажмите для Выгрузки'; return fullText.trim();
            } catch (error) { console.error('Error parsing PDF:', error); dropZoneInstruction.textContent = 'Сбросте Файлы Сюда или Нажмите для Выгрузки'; return `[Error extracting text from PDF: ${escapeHTML(error.message)}]`; }
        }
        async function addFilesToList(files) {
            const maxFileSize = 50 * 1024 * 1024;
            const allowedTypes = ['text/plain', 'text/markdown', 'text/csv', 'text/html', 'text/xml', 'text/css', 'text/javascript', 'application/json', 'application/pdf', 'application/x-python-code', 'application/xml', 'image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/bmp'];
            const allowFilesWithoutType = true;
            for (const file of files) {
                if (attachedFiles.some(f => f.name === file.name)) { alert(`Файл "${escapeHTML(file.name)}" уже прикреплён.`); continue; }
                if (file.size > maxFileSize) { alert(`Файл "${escapeHTML(file.name)}" слишком большой (${(file.size / 1024 / 1024).toFixed(1)} MB). Максимальный размер ${maxFileSize / 1024 / 1024} MB.`); continue; }
                const fileType = file.type || 'unknown'; const isAllowedType = allowedTypes.some(type => fileType.startsWith(type)); const isUnknownButAllowed = allowFilesWithoutType && fileType === 'unknown';
                if (!isAllowedType && !isUnknownButAllowed) { alert(`Тип файла "${escapeHTML(fileType)}" для "${escapeHTML(file.name)}" не поддерживается.`); continue; }
                if (isUnknownButAllowed) console.warn(`Файл "${escapeHTML(file.name)}" имеет неизвестный тип. Попытка прочитать как текст.`);
                const fileId = `file-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`; const reader = new FileReader();
                reader.onload = async (e) => {
                    let fileContent = e.target.result; let processedFileType = fileType;
                    try {
                        if (fileType === 'application/pdf') { dropZoneInstruction.textContent = `Обработка PDF: ${escapeHTML(file.name)}...`; fileContent = await extractTextFromPdf(e.target.result); }
                        else if (!fileType.startsWith('image/') && typeof fileContent !== 'string') { fileContent = "[Error reading file content as text]"; }
                        attachedFiles.push({ id: fileId, name: file.name, content: fileContent, type: processedFileType }); renderAttachedFilesUI();
                    } catch (processingError) { console.error(`Error processing file ${file.name}:`, processingError); alert(`Ошибка обработки файла "${escapeHTML(file.name)}": ${processingError.message}`); if (fileType === 'application/pdf') dropZoneInstruction.textContent = 'Сбросте Файлы Сюда или Нажмите для Выгрузки'; }
                };
                reader.onerror = (e) => { console.error("Error reading file:", file.name, e); alert("Ошибка чтения файла: " + escapeHTML(file.name)); if (fileType === 'application/pdf') dropZoneInstruction.textContent = 'Сбросте Файлы Сюда или Нажмите для Выгрузки'; };
                if (fileType === 'application/pdf') reader.readAsArrayBuffer(file); else if (fileType.startsWith('image/')) reader.readAsDataURL(file); else reader.readAsText(file);
            }
            fileInputHidden.value = '';
        }
        function removeSpecificFile(fileId) { attachedFiles = attachedFiles.filter(f => f.id !== fileId); renderAttachedFilesUI(); fileInputHidden.value = ''; }
        function clearAllAttachedFiles() { attachedFiles = []; renderAttachedFilesUI(); fileInputHidden.value = ''; }

        function resetChat() {
            if (isAwaitingResponse && currentStreamController) {
                console.log("Aborting active model stream for reset...");
                currentStreamController.abort(); // Signal fetch to abort
            }
            // These must be reset *immediately* to stop any further stream processing attempts
            isAwaitingResponse = false;
            currentStreamController = null; // Clear the controller
            currentAiMessageElement = null;
            currentAiMessageContentDiv = null; // This is critical to prevent errors from stale references

            // Clear UI elements
            chatMessagesArea.innerHTML = '';
            localStorage.removeItem('conversationHistory');
            localStorage.removeItem('conversationHistoryUI');
            clearAllAttachedFiles();

            // Reset UI state and enable inputs
            sendButton.disabled = false;
            userInput.disabled = false;
            userInput.value = '';
            adjustTextareaHeight();
            updateInputHighlighting();
            fileManagementArea.classList.remove('disabled-drop-zone');
            if (scrapeStatusElement) scrapeStatusElement.textContent = "";
            userScrolledUp = false;
            userInput.focus();
            console.log("Chat reset.");
        }

        function scrollToBottom() {
            const isNearBottom = chatMessagesArea.scrollHeight - chatMessagesArea.scrollTop <= chatMessagesArea.clientHeight + 50;
            if (!userScrolledUp || isNearBottom) { chatMessagesArea.scrollTop = chatMessagesArea.scrollHeight; if (isNearBottom && userScrolledUp) userScrolledUp = false; }
        }
        chatMessagesArea.addEventListener('scroll', () => { if (isAwaitingResponse && currentAiMessageContentDiv) { const isNearBottom = chatMessagesArea.scrollHeight - chatMessagesArea.scrollTop <= chatMessagesArea.clientHeight + 50; userScrolledUp = !isNearBottom; } }, { passive: true });

        function updateInputHighlighting() {
            if (!userInputHighlighter || !userInput) return; const text = userInput.value;
            userInputHighlighter.scrollTop = userInput.scrollTop; userInputHighlighter.scrollLeft = userInput.scrollLeft;
            if (!scrapeUrlCheckbox.checked || !text) { userInputHighlighter.innerHTML = ''; return; }
            let highlightedText = escapeHTML(text); const urls = extractUrls(text);
            if (urls.length > 0) {
                urls.sort((a, b) => b.length - a.length);
                urls.forEach(url => { const escapedUrlHtml = escapeHTML(url); const urlRegExp = new RegExp(RegExp.escape(escapedUrlHtml), 'g'); highlightedText = highlightedText.replace(urlRegExp, `<span class="highlighted-url">${escapedUrlHtml}</span>`); });
            }
            if (text.endsWith('\n')) highlightedText += ' '; userInputHighlighter.innerHTML = highlightedText;
        }
        function adjustTextareaHeight() {
            if (!userInput || !userInputHighlighter) return;
            userInput.style.height = 'auto'; userInputHighlighter.style.height = 'auto';
            const scrollHeight = userInput.scrollHeight; const maxHeight = 250; const newHeight = Math.min(scrollHeight, maxHeight);
            userInput.style.height = `${newHeight}px`; userInputHighlighter.style.height = `${newHeight}px`;
            userInput.style.overflowY = scrollHeight > maxHeight ? 'scroll' : 'hidden';
        }

        async function checkURLParams() {
            if (urlParams.has('api')) {
                OLLAMA_API_URL = urlParams.get('api');
            }
            await fetchModels(); // Fetch models on initial load
            if (urlParams.has('hide_api')) {
                updateOllamaUrlButton.style.display = 'none';
                ollamaUrlInput.style.display = 'none';
                apiLabel.style.display = 'none';
            }
            if (urlParams.has('model')) {
                modelSelect.value = urlParams.get('model');
            }
            if (urlParams.has('q')) {
                userInput.value = urlParams.get('q');
                sendMessage();
            }
        }

        sendButton.addEventListener('click', sendMessage);
        resetChatButton.addEventListener('click', resetChat);
        userInput.addEventListener('keydown', (event) => { if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); } if (['Enter', 'Backspace', 'Delete'].includes(event.key)) setTimeout(adjustTextareaHeight, 0); });
        userInput.addEventListener('input', () => { updateInputHighlighting(); adjustTextareaHeight(); });
        userInput.addEventListener('scroll', () => { if (userInputHighlighter) { userInputHighlighter.scrollTop = userInput.scrollTop; userInputHighlighter.scrollLeft = userInput.scrollLeft; } }, { passive: true });
        scrapeUrlCheckbox.addEventListener('change', updateInputHighlighting);
        systemPromptToggle.addEventListener('click', () => {
            const isHidden = systemPromptContent.style.display === 'none'; systemPromptContent.style.display = isHidden ? 'block' : 'none';
            systemPromptToggle.querySelector('.toggle-icon').textContent = isHidden ? '[-]' : '[+]'; if (isHidden) systemPromptInput.focus();
        });
        updateOllamaUrlButton.addEventListener('click', () => {
            const newUrl = ollamaUrlInput.value.trim().replace(/\/$/, '');
            if (newUrl && (newUrl.startsWith('http://') || newUrl.startsWith('https://'))) {
                if (newUrl !== OLLAMA_API_URL) { OLLAMA_API_URL = newUrl; console.log(`Ollama API URL updated to: ${OLLAMA_API_URL}`); } fetchModels();
            } else { alert("Пожалуйста введите правильный Ollama API URL (должен начинаться с http:// или https://)."); ollamaUrlInput.value = OLLAMA_API_URL; ollamaUrlInput.focus(); }
        });
        themeToggle.addEventListener('click', () => {
            body.classList.toggle('dark-theme');
            prismLink.href = body.classList.contains('dark-theme') ? 'https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism-dark.min.css' : 'https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css';
        });
        fileManagementArea.addEventListener('click', () => { if (!fileManagementArea.classList.contains('disabled-drop-zone')) fileInputHidden.click(); });
        fileInputHidden.addEventListener('change', (event) => { if (event.target.files.length > 0) addFilesToList(event.target.files); });
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => { fileManagementArea.addEventListener(eventName, preventDefaults, false); document.body.addEventListener(eventName, preventDefaults, false); });
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        ['dragenter', 'dragover'].forEach(eventName => { fileManagementArea.addEventListener(eventName, () => { if (!fileManagementArea.classList.contains('disabled-drop-zone')) fileManagementArea.classList.add('drag-over'); }, false); });
        ['dragleave', 'drop'].forEach(eventName => { fileManagementArea.addEventListener(eventName, () => { fileManagementArea.classList.remove('drag-over'); }, false); });
        fileManagementArea.addEventListener('drop', (event) => { if (!fileManagementArea.classList.contains('disabled-drop-zone')) { const files = event.dataTransfer.files; if (files && files.length > 0) addFilesToList(files); } }, false);
        document.addEventListener('DOMContentLoaded', () => { ollamaUrlInput.value = OLLAMA_API_URL; checkURLParams(); userInput.focus(); renderAttachedFilesUI(); updateInputHighlighting(); adjustTextareaHeight(); console.log("Ollama Standalone Chat Initialized."); });
    </script>
</body>
</html>
